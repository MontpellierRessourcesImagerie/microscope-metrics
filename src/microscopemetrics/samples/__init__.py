# Main samples module defining the sample superclass

import logging
from abc import ABC, abstractmethod

import numpy as np

from microscopemetrics.data_schema import core_schema

# We are defining some global dictionaries to register the different analysis types
IMAGE_ANALYSIS_REGISTRY = {}
DATASET_ANALYSIS_REGISTRY = {}
PROGRESSION_ANALYSIS_REGISTRY = {}


# Decorators to register exposed analysis functions
def register_image_analysis(cls):
    IMAGE_ANALYSIS_REGISTRY[cls.__name__] = cls
    return cls


def register_dataset_analysis(cls):
    DATASET_ANALYSIS_REGISTRY[cls.__name__] = cls
    return cls


def register_progression_analysis(cls):
    PROGRESSION_ANALYSIS_REGISTRY[cls.__name__] = cls
    return cls


# Create a logging service
logger = logging.getLogger(__name__)


class AnalysisMixin(ABC):
    """This is a mixin class defining some helper functions to work with the linkml autogenerated schema."""

    def __init__(self):
        pass

    def describe_requirements(self):
        print(self.input.describe_requirements())

    def numpy_to_inlined_image(self, array: np.ndarray, name: str = None) -> core_schema.Image:
        """Converts a numpy array to an inlined image"""
        if array.ndim == 5:
            return core_schema.Image5D(
                name=name,
                data=array.flatten().tolist(),
                t=core_schema.TimeSeries(values=array.shape[0]),
                z=core_schema.PixelSeries(values=array.shape[1]),
                y=core_schema.PixelSeries(values=array.shape[2]),
                x=core_schema.PixelSeries(values=array.shape[3]),
                c=core_schema.ChannelSeries(values=array.shape[4]),
            )

    def validate_requirements(self) -> bool:
        logger.info("Validating requirements...")
        # TODO: check image dimensions/shape
        return True
